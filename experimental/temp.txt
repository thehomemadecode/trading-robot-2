    # get quoteAsset
    if fileuse:
        file = open(filename, "r")
        for i in file:
            temp = i
        file.close()
        alldata = eval(temp)
        list1 = []
        for i in alldata['symbols']:
            list1.append(i['quoteAsset'])
        unique_list = []
        for x in list1:
            if x not in unique_list:
                unique_list.append(x)
        print(unique_list)
# -----------------------------------------------------------------------------------------------
alldataindex = ['timezone', 'serverTime', 'rateLimits', 'exchangeFilters', 'symbols']
# -----------------------------------------------------------------------------------------------
https://github.com/binance/binance-connector-python/blob/master/binance/spot/_market.py
# -----------------------------------------------------------------------------------------------
import multiprocessing
import asyncio
import websockets
import json

async def connectsocket(queue):
    #async with websockets.connect("wss://data-stream.binance.vision:443/ws/btcusdt@kline_1m") as ws:
    async with websockets.connect("wss://data-stream.binance.vision:443/ws/btcusdt@miniTicker") as ws:
        fiyat2 = 0
        while True:
            mesaj = await ws.recv()
            temp = json.loads(mesaj)
            #fiyat = temp['k']['c']
            fiyat = temp['c']
            if (fiyat != fiyat2):
                queue.put(fiyat)
                fiyat2 = fiyat

def getprice(queue):
    asyncio.run(connectsocket(queue))

def worker(queue):
    counter = 1
    price2 = 0
    while counter:
        price = queue.get()
        queue.empty()
        time.sleep(1)
        if (price != price2):
            print("Fiyat:", price)
            counter -= 1
            price2 = price

def main():
    q = multiprocessing.Queue()
    p3 = multiprocessing.Process(target=getprice, args=(q,))
    p2 = multiprocessing.Process(target=worker, args=(q,))
    p3.start()
    p2.start()
    p2.join()
    p3.terminate()
# -----------------------------------------------------------------------------------------------
    seritoplam = 0
    for s in range(totalbar-1,totalbar-period-1,-1):
        seri[totalbar-s-1] = float(bar[s][4])
        seritoplam += seri[totalbar-s-1]
    print(seritoplam/9)
# -----------------------------------------------------------------------------------------------
def func():
    try:
        pass
    except Exception as err:
        import sys
        #print('Bir hata oluştu:')
        #print('Satır numarası: {}'.format(sys.exc_info()[-1].tb_lineno))
        #print(type(err).__name__, err)
        exit()
# -----------------------------------------------------------------------------------------------
    # get selected symbol's OHLCV & data & calculate indicators
    s = 0 # temporary limiter counter
    for symbol in symbollist:
        mdate = dateconvert(hdate)
        bars = client.klines(symbol, graphtimeperiod, startTime = mdate, limit = maxklines)
        totalbar = len(bars)
        barOHLC = []
        for b in bars:
            barOHLCrow = []
            for col in range(1,6):
                barOHLCrow.append(float(b[col]))
            barOHLCrow.append(float(((barOHLCrow[0]+barOHLCrow[3])/2)*barOHLCrow[4]))
            barOHLC.append(barOHLCrow)
        # print selected symbol OHLC bars
        # too many lines!
        #print("[.]",totalbar,symbol,":",barOHLC)
        
        # get and print simple moving average
        OHLCpoint = letter_to_number(OHLC)
        smaresult = round(trobot2.sma(barOHLC,OHLCpoint-1,period),4)
        volKlot = round((barOHLC[totalbar-1][4]/1000),2)
        volKusd = round((barOHLC[totalbar-1][5]/1000),2)
        print("[*] ",symbol," SMA(",period,")",OHLC,": ",round((smaresult/1000),2)," Volume(K):",volKlot," Volume($K):",volKusd,sep="")
        s += 1
        time.sleep(3)
        if s==1:break # temporary limiter
# -----------------------------------------------------------------------------------------------
# Step 1: Define your functions
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

# Step 2: Create a dictionary mapping string names to functions
function_map = {
    'add': add,
    'subtract': subtract,
    'multiply': multiply
}

# Step 3: Execute a function by its string name with parameters
def execute_function(func_name, *args):
    if func_name in function_map:
        # Retrieve the function from the dictionary and call it with parameters
        return function_map[func_name](*args)
    else:
        return "Function not found"

# Example usage
result_add = execute_function('add', 5, 3)
print(f'Addition result: {result_add}')

result_subtract = execute_function('subtract', 10, 4)
print(f'Subtraction result: {result_subtract}')

result_multiply = execute_function('multiply', 6, 7)
print(f'Multiplication result: {result_multiply}')
# -----------------------------------------------------------------------------------------------
dbcur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name ASC;")
tables = dbcur.fetchall()
dbcur.execute("PRAGMA table_info('{}');".format(tables[0][0]))
columns = dbcur.fetchall()
column_names = [column[1] for column in columns]
select_columns = ", ".join(column_names[2:-6])
select_columns = select_columns+", "+column_names[8]
# -----------------------------------------------------------------------------------------------
	char* assetname = "";
	PyObject* py_string_object = PyList_GetItem(data, 0);
	if (PyUnicode_Check(py_string_object)) {
		PyObject* py_bytes_object = PyUnicode_AsUTF8String(py_string_object);
		if (py_bytes_object != NULL) {
			assetname = PyBytes_AsString(py_bytes_object);
			if (assetname != NULL) {
				// assetname kullanılabilir
				printf("Asset Name: %s\n", assetname);
			}
			Py_DECREF(py_bytes_object);
		}
	}

	return Py_BuildValue("s", assetname);
# -----------------------------------------------------------------------------------------------
#include <Python.h>
#include <stdio.h>
#include <string.h>

/* TA functions section begin */
double sma(double *data, int len) {
    double total = 0;
    for (int i=0; i<len; i++) {
        total += data[i];
    }
    total = total / len;
    return total;
}

double ema(double *data, int len) {
    double total = 0;
    for (int i=0; i<len; i++) {
        total += data[i];
    }
    total = total / len;
    return total;
}
/* TA functions section end */

/* function map section begin */
typedef double (*func_ptr_double)(double*, int);
typedef struct {
    const char *name;
    func_ptr_double func;
} FunctionMap;
FunctionMap functions[] = {
    {"sma", (func_ptr_double)sma},
    {"ema", (func_ptr_double)ema},
};
func_ptr_double get_function(const char *name) {
    for (size_t i = 0; i < sizeof(functions) / sizeof(functions[0]); ++i) {
        if (strcmp(name, functions[i].name) == 0) {
            return functions[i].func;
        }
    }
    return NULL;
}
/* function map section end */

/* Reception function for incoming data: */
static PyObject *receptionC(PyObject *self, PyObject *args) {
    PyObject* data;
    PyObject* cols;
    PyObject* analysisrules;
    if (!PyArg_ParseTuple(args, "OOO", &data, &cols, &analysisrules)) {
        return NULL;
    }

    Py_ssize_t num_rows = PyList_Size(data);
    Py_ssize_t num_cols = 0;
    double **data_c = malloc(num_rows * sizeof(double *));
    for (Py_ssize_t i = 0; i < num_rows; ++i) {
        PyObject *row = PyList_GetItem(data, i);
        num_cols = PyList_Size(row);
        data_c[i] = malloc(num_cols * sizeof(double));
        for (Py_ssize_t j = 0; j < num_cols; ++j) {
            PyObject *item = PyList_GetItem(row, j);
            data_c[i][j] = PyFloat_AsDouble(item);
        }
    }

    Py_ssize_t len_cols = PyList_Size(cols);
    int cols_c[len_cols];
    for (Py_ssize_t i = 0; i < len_cols; ++i) {
        PyObject *item = PyList_GetItem(cols, i);
        cols_c[i] = (int)PyLong_AsLong(item);
    }

    Py_ssize_t len = PyList_Size(analysisrules);
    const char *function_names[len];
    int function_names_len[len];
    for (Py_ssize_t i = 0; i < len; ++i) {
        PyObject *item = PyList_GetItem(analysisrules, i);
        PyObject *item0 = PyList_GetItem(item, 0);
        PyObject *item1 = PyList_GetItem(item, 1);
        const char *name = PyUnicode_AsUTF8(item0);
        int name_len = (int)PyLong_AsLong(item1);
        function_names[i] = name;
        function_names_len[i] = name_len;
    }

    for (size_t i = 0; i < sizeof(function_names) / sizeof(function_names[0]); ++i) {
        const char *name = function_names[i];
        func_ptr_double func = get_function(name);
        for (Py_ssize_t j=0; j<num_rows; j++) {
            printf("%s = %0.4lf\n", name, func(data_c[j],function_names_len[i]));
        }
    }


    double signal = 0;
    double signal2 = 0;
    return Py_BuildValue("dd", signal, signal2);
}
/* Reception function end */

/* for Python.h to the end of code */
static PyMethodDef trobot2Methods[] = {
    {"receptionP", receptionC, METH_VARARGS, "Reception function for incoming data."},
    {NULL, NULL, 0, NULL}
};
static struct PyModuleDef trobot2 = {
    PyModuleDef_HEAD_INIT,
    "trobot2",
    "Python interface for trobot2 C library functions",
    -1,
    trobot2Methods
};
PyMODINIT_FUNC PyInit_trobot2(void) {
    return PyModule_Create(&trobot2);
}
/* end of code */
# -----------------------------------------------------------------------------------------------

# -----------------------------------------------------------------------------------------------

# -----------------------------------------------------------------------------------------------

# -----------------------------------------------------------------------------------------------
